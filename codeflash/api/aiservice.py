from __future__ import annotations

import json
import logging
import os
import pickle
import platform
import time
from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple

import requests
from pydantic.dataclasses import dataclass
from pydantic.json import pydantic_encoder

from codeflash.code_utils.env_utils import get_codeflash_api_key
from codeflash.telemetry.posthog import ph

if TYPE_CHECKING:
    from codeflash.discovery.functions_to_optimize import FunctionToOptimize
    from codeflash.models.ExperimentMetadata import ExperimentMetadata


@dataclass(frozen=True)
class OptimizedCandidate:
    source_code: str
    explanation: str
    optimization_id: str


class AiServiceClient:
    def __init__(self):
        self.base_url = self.get_aiservice_base_url()
        self.headers = {"Authorization": f"Bearer {get_codeflash_api_key()}"}

    def get_aiservice_base_url(self) -> str:
        if os.environ.get("CODEFLASH_AIS_SERVER", default="prod").lower() == "local":
            logging.info("Using local AI Service at http://localhost:8000")
            return "http://localhost:8000"
        return "https://app.codeflash.ai"

    def make_ai_service_request(
        self,
        endpoint: str,
        method: str = "POST",
        payload: Optional[Dict[str, Any]] = None,
        timeout: float = None,
    ) -> requests.Response:
        """Make an API request to the given endpoint on the AI service.

        :param endpoint: The endpoint to call, e.g., "/optimize".
        :param method: The HTTP method to use ('GET' or 'POST').
        :param payload: Optional JSON payload to include in the POST request body.
        :param timeout: The timeout for the request.
        :return: The response object from the API.
        """
        url = f"{self.base_url}/ai{endpoint}"
        if method.upper() == "POST":
            json_payload = json.dumps(payload, indent=None, default=pydantic_encoder)
            headers = {**self.headers, "Content-Type": "application/json"}
            response = requests.post(url, data=json_payload, headers=headers, timeout=timeout)
        else:
            response = requests.get(url, headers=self.headers, timeout=timeout)
        # response.raise_for_status()  # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
        return response

    def optimize_python_code(
        self,
        source_code: str,
        trace_id: str,
        num_candidates: int = 10,
        experiment_metadata: ExperimentMetadata | None = None,
    ) -> list[OptimizedCandidate]:
        """Optimize the given python code for performance by making a request to the Django endpoint.

        Parameters
        ----------
        - source_code (str): The python code to optimize.
        - num_variants (int): Number of optimization variants to generate. Default is 10.

        Returns
        -------
        - List[Optimization]: A list of Optimization objects.

        """
        payload = {
            "source_code": source_code,
            "num_variants": num_candidates,
            "trace_id": trace_id,
            "python_version": platform.python_version(),
            "experiment_metadata": experiment_metadata,
        }
        logging.info("Generating optimized candidates ...")
        try:
            response = self.make_ai_service_request(
                "/optimize",
                payload=payload,
                timeout=600,
            )
        except requests.exceptions.RequestException as e:
            logging.exception(f"Error generating optimized candidates: {e}")
            ph("cli-optimize-error-caught", {"error": str(e)})
            return []

        if response.status_code == 200:
            optimizations_json = response.json()["optimizations"]
            logging.info(f"Generated {len(optimizations_json)} candidates.")
            return [
                OptimizedCandidate(
                    source_code=opt["source_code"],
                    explanation=opt["explanation"],
                    optimization_id=opt["optimization_id"],
                )
                for opt in optimizations_json
            ]
        try:
            error = response.json()["error"]
        except Exception:
            error = response.text
        logging.error(f"Error generating optimized candidates: {response.status_code} - {error}")
        ph(
            "cli-optimize-error-response",
            {"response_status_code": response.status_code, "error": error},
        )
        return []

    def log_results(
        self,
        function_trace_id: str,
        speedup_ratio: dict[str, float] | None,
        original_runtime: float | None,
        optimized_runtime: dict[str, float] | None,
        is_correct: dict[str, bool] | None,
    ) -> None:
        """Log features to the database.

        Parameters
        ----------
        - function_trace_id (str): The UUID.
        - speedup_ratio (Optional[Dict[str, float]]): The speedup.
        - original_runtime (Optional[Dict[str, float]]): The original runtime.
        - optimized_runtime (Optional[Dict[str, float]]): The optimized runtime.
        - is_correct (Optional[Dict[str, bool]]): Whether the optimized code is correct.

        """
        payload = {
            "trace_id": function_trace_id,
            "speedup_ratio": speedup_ratio,
            "original_runtime": original_runtime,
            "optimized_runtime": optimized_runtime,
            "is_correct": is_correct,
        }
        try:
            self.make_ai_service_request("/log_features", payload=payload, timeout=5)
        except requests.exceptions.RequestException as e:
            logging.exception(f"Error logging features: {e}")

    def generate_regression_tests(
        self,
        source_code_being_tested: str,
        function_to_optimize: FunctionToOptimize,
        dependent_function_names: list[str],
        module_path: str,
        test_module_path: str,
        test_framework: str,
        test_timeout: int,
        trace_id: str,
    ) -> Optional[Tuple[str, str]]:
        """Generate regression tests for the given function by making a request to the Django endpoint.

        Parameters
        ----------
        - source_code_being_tested (str): The source code of the function being tested.
        - function_to_optimize (FunctionToOptimize): The function to optimize.
        - dependent_function_names (list[Source]): List of dependent function names.
        - module_path (str): The module path where the function is located.
        - test_module_path (str): The module path for the test code.
        - test_framework (str): The test framework to use, e.g., "pytest".
        - test_timeout (int): The timeout for each test in seconds.

        Returns
        -------
        - Dict[str, str] | None: The generated regression tests and instrumented tests, or None if an error occurred.

        """
        assert test_framework in [
            "pytest",
            "unittest",
        ], f"Invalid test framework, got {test_framework} but expected 'pytest' or 'unittest'"
        payload = {
            "source_code_being_tested": source_code_being_tested,
            "function_to_optimize": function_to_optimize,
            "dependent_function_names": dependent_function_names,
            "module_path": module_path,
            "test_module_path": test_module_path,
            "test_framework": test_framework,
            "test_timeout": test_timeout,
            "trace_id": trace_id,
            "python_version": platform.python_version(),
        }
        try:
            # response = self.make_ai_service_request("/testgen", payload=payload, timeout=600)
            # response = pickle.loads(
            #     b"\x80\x04\x95\xa4Y\x00\x00\x00\x00\x00\x00\x8c\x0frequests.models\x94\x8c\x08Response\x94\x93\x94)\x81\x94}\x94(\x8c\x08_content\x94B%I\x00\x00{\"generated_tests\": \"# imports\\n# function to test\\nimport itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\nimport pytest  # used for our unit tests\\nfrom codeflash.result.list_example import compare_lists\\n\\n# unit tests\\n\\ndef test_identical_lists():\\n    assert compare_lists([1, 2, 3], [1, 2, 3]) == ({1, 2, 3}, set(), set())\\n\\ndef test_completely_different_lists():\\n    assert compare_lists([1, 2, 3], [4, 5, 6]) == (set(), {1, 2, 3}, {4, 5, 6})\\n\\ndef test_some_common_elements():\\n    assert compare_lists([1, 2, 3], [2, 3, 4]) == ({2, 3}, {1}, {4})\\n\\ndef test_first_list_longer():\\n    assert compare_lists([1, 2, 3, 4], [2, 3]) == ({2, 3}, {1, 4}, set())\\n\\ndef test_second_list_longer():\\n    assert compare_lists([1, 2], [1, 2, 3, 4]) == ({1, 2}, set(), {3, 4})\\n\\ndef test_duplicates_in_one_list():\\n    assert compare_lists([1, 1, 2, 2], [1, 2]) == ({1, 2}, set(), set())\\n\\ndef test_duplicates_in_both_lists():\\n    assert compare_lists([1, 1, 2, 2], [1, 1, 2, 2]) == ({1, 2}, set(), set())\\n\\ndef test_custom_comparison_logic():\\n    assert compare_lists([{'v': 1}, {'v': 2}], [1, 2], value_func1=lambda x: x['v']) == ({1, 2}, set(), set())\\n\\ndef test_different_comparison_logic():\\n    assert compare_lists([{'v': 1}, {'v': 2}], [{'val': 1}, {'val': 2}], value_func1=lambda x: x['v'], value_func2=lambda x: x['val']) == ({1, 2}, set(), set())\\n\\ndef test_empty_lists():\\n    assert compare_lists([], []) == (set(), set(), set())\\n    assert compare_lists([1, 2, 3], []) == (set(), {1, 2, 3}, set())\\n    assert compare_lists([], [1, 2, 3]) == (set(), set(), {1, 2, 3})\\n\\ndef test_single_element_lists():\\n    assert compare_lists([1], [1]) == ({1}, set(), set())\\n    assert compare_lists([1], [2]) == (set(), {1}, {2})\\n\\ndef test_strings():\\n    assert compare_lists(['a', 'b', 'c'], ['b', 'c', 'd']) == ({'b', 'c'}, {'a'}, {'d'})\\n\\ndef test_mixed_types():\\n    assert compare_lists([1, 'a', 3.0], [1, 'b', 3.0]) == ({1, 3.0}, {'a'}, {'b'})\\n\\ndef test_large_lists():\\n    assert compare_lists(list(range(1000)), list(range(500, 1500))) == (set(range(500, 1000)), set(range(500)), set(range(1000, 1500)))\\n    assert compare_lists(list(range(10000)), list(range(5000, 15000))) == (set(range(5000, 10000)), set(range(5000)), set(range(10000, 15000)))\\n\\ndef test_complex_objects():\\n    assert compare_lists([{'v': {'a': 1}}, {'v': {'b': 2}}], [{'v': {'a': 1}}, {'v': {'c': 3}}], value_func1=lambda x: x['v'], value_func2=lambda x: x['v']) == ({'a': 1}, {'b': 2}, {'c': 3})\\n\\ndef test_none_values():\\n    assert compare_lists([None, 1, 2], [None, 2, 3]) == ({None, 2}, {1}, {3})\\n\\ndef test_boolean_values():\\n    assert compare_lists([True, False], [False, True]) == ({True, False}, set(), set())\\n\\ndef test_nested_lists():\\n    assert compare_lists([[1, 2], [3, 4]], [[1, 2], [5, 6]]) == ({(1, 2)}, {(3, 4)}, {(5, 6)})\\n\\ndef test_no_mutation():\\n    li1 = [1, 2, 3]\\n    li2 = [2, 3, 4]\\n    compare_lists(li1, li2)\\n    assert li1 == [1, 2, 3]\\n    assert li2 == [2, 3, 4]\\n\\n# Run the tests\\npytest.main()\", \"instrumented_tests\": \"import dill as pickle\\nimport os\\ndef _log__test__values(values, duration, test_name, invocation_id):\\n    iteration = os.environ[\\\"CODEFLASH_TEST_ITERATION\\\"]\\n    with open(os.path.join('{codeflash_run_tmp_dir_client_side}', f'test_return_values_{iteration}.bin'), 'ab') as f:\\n        return_bytes = pickle.dumps(values)\\n        _test_name = f\\\"{test_name}\\\".encode(\\\"ascii\\\")\\n        f.write(len(_test_name).to_bytes(4, byteorder='big'))\\n        f.write(_test_name)\\n        f.write(duration.to_bytes(8, byteorder='big'))\\n        f.write(len(return_bytes).to_bytes(4, byteorder='big'))\\n        f.write(return_bytes)\\n        f.write(len(invocation_id).to_bytes(4, byteorder='big'))\\n        f.write(invocation_id.encode(\\\"ascii\\\"))\\nimport inspect\\nimport time\\nimport gc\\nfrom codeflash.result.list_example import compare_lists\\n\\ndef codeflash_wrap(wrapped, test_module_name, test_class_name, test_name, line_id, *args, **kwargs):\\n    test_id = f'{test_module_name}:{test_class_name}:{test_name}:{line_id}'\\n    if not hasattr(codeflash_wrap, 'index'):\\n        codeflash_wrap.index = {}\\n    if test_id in codeflash_wrap.index:\\n        codeflash_wrap.index[test_id] += 1\\n    else:\\n        codeflash_wrap.index[test_id] = 0\\n    codeflash_test_index = codeflash_wrap.index[test_id]\\n    invocation_id = f'{line_id}_{codeflash_test_index}'\\n    gc.disable()\\n    counter = time.perf_counter_ns()\\n    return_value = wrapped(*args, **kwargs)\\n    codeflash_duration = time.perf_counter_ns() - counter\\n    gc.enable()\\n    return (return_value, codeflash_duration, invocation_id)\\nimport pytest\\nimport itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\ndef test_identical_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [1, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_identical_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_identical_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_completely_different_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [4, 5, 6])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_completely_different_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_completely_different_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_some_common_elements():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [2, 3, 4])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_some_common_elements', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_some_common_elements:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_first_list_longer():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3, 4], [2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_first_list_longer', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_first_list_longer:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_second_list_longer():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2], [1, 2, 3, 4])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_second_list_longer', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_second_list_longer:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_duplicates_in_one_list():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 1, 2, 2], [1, 2])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_duplicates_in_one_list', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_duplicates_in_one_list:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_duplicates_in_both_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 1, 2, 2], [1, 1, 2, 2])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_duplicates_in_both_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_duplicates_in_both_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_custom_comparison_logic():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([{'v': 1}, {'v': 2}], [1, 2], value_func1=lambda x: x['v'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_custom_comparison_logic', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_custom_comparison_logic:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_different_comparison_logic():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([{'v': 1}, {'v': 2}], [{'val': 1}, {'val': 2}], value_func1=lambda x: x['v'], value_func2=lambda x: x['val'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_different_comparison_logic', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_different_comparison_logic:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_empty_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([], [])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_empty_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_empty_lists:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_empty_lists', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_empty_lists:compare_lists:1', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([], [1, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_empty_lists', '2', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_empty_lists:compare_lists:2', codeflash_invocation_id)\\n\\ndef test_single_element_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1], [1])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_single_element_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_single_element_lists:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1], [2])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_single_element_lists', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_single_element_lists:compare_lists:1', codeflash_invocation_id)\\n\\ndef test_strings():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(['a', 'b', 'c'], ['b', 'c', 'd'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_strings', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_strings:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_mixed_types():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 'a', 3.0], [1, 'b', 3.0])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_mixed_types', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_mixed_types:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_large_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(1000)), list(range(500, 1500)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_large_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_large_lists:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(10000)), list(range(5000, 15000)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_large_lists', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_large_lists:compare_lists:1', codeflash_invocation_id)\\n\\ndef test_complex_objects():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([{'v': {'a': 1}}, {'v': {'b': 2}}], [{'v': {'a': 1}}, {'v': {'c': 3}}], value_func1=lambda x: x['v'], value_func2=lambda x: x['v'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_complex_objects', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_complex_objects:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_none_values():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([None, 1, 2], [None, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_none_values', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_none_values:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_boolean_values():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([True, False], [False, True])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_boolean_values', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_boolean_values:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_nested_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([[1, 2], [3, 4]], [[1, 2], [5, 6]])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_nested_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_nested_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_no_mutation():\\n    li1 = [1, 2, 3]\\n    li2 = [2, 3, 4]\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(li1, li2)\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_no_mutation', '2', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_no_mutation:compare_lists:2', codeflash_invocation_id)\\npytest.main()\"}\x94\x8c\x0bstatus_code\x94K\xc8\x8c\x07headers\x94\x8c\x13requests.structures\x94\x8c\x13CaseInsensitiveDict\x94\x93\x94)\x81\x94}\x94\x8c\x06_store\x94\x8c\x0bcollections\x94\x8c\x0bOrderedDict\x94\x93\x94)R\x94(\x8c\x04date\x94\x8c\x04Date\x94\x8c\x1dTue, 14 May 2024 01:35:43 GMT\x94\x86\x94\x8c\x0ccontent-type\x94\x8c\x0cContent-Type\x94\x8c\x1fapplication/json; charset=utf-8\x94\x86\x94\x8c\x0econtent-length\x94\x8c\x0eContent-Length\x94\x8c\x0518725\x94\x86\x94\x8c\nconnection\x94\x8c\nConnection\x94\x8c\nkeep-alive\x94\x86\x94\x8c\x06server\x94\x8c\x06Server\x94\x8c\x07uvicorn\x94\x86\x94\x8c\x16x-content-type-options\x94\x8c\x16X-Content-Type-Options\x94\x8c\x07nosniff\x94\x86\x94\x8c\x0freferrer-policy\x94\x8c\x0fReferrer-Policy\x94\x8c\x0bsame-origin\x94\x86\x94\x8c\x1across-origin-opener-policy\x94\x8c\x1aCross-Origin-Opener-Policy\x94\x8c\x0bsame-origin\x94\x86\x94usb\x8c\x03url\x94\x8c#https://app.codeflash.ai/ai/testgen\x94\x8c\x07history\x94]\x94\x8c\x08encoding\x94\x8c\x05utf-8\x94\x8c\x06reason\x94\x8c\x02OK\x94\x8c\x07cookies\x94\x8c\x10requests.cookies\x94\x8c\x11RequestsCookieJar\x94\x93\x94)\x81\x94}\x94(\x8c\x07_policy\x94\x8c\x0ehttp.cookiejar\x94\x8c\x13DefaultCookiePolicy\x94\x93\x94)\x81\x94}\x94(\x8c\x08netscape\x94\x88\x8c\x07rfc2965\x94\x89\x8c\x13rfc2109_as_netscape\x94N\x8c\x0chide_cookie2\x94\x89\x8c\rstrict_domain\x94\x89\x8c\x1bstrict_rfc2965_unverifiable\x94\x88\x8c\x16strict_ns_unverifiable\x94\x89\x8c\x10strict_ns_domain\x94K\x00\x8c\x1cstrict_ns_set_initial_dollar\x94\x89\x8c\x12strict_ns_set_path\x94\x89\x8c\x10secure_protocols\x94\x8c\x05https\x94\x8c\x03wss\x94\x86\x94\x8c\x10_blocked_domains\x94)\x8c\x10_allowed_domains\x94N\x8c\x04_now\x94J\xef\xbfBfub\x8c\x08_cookies\x94}\x94hWJ\xef\xbfBfub\x8c\x07elapsed\x94\x8c\x08datetime\x94\x8c\ttimedelta\x94\x93\x94K\x00K&JT\xf3\x04\x00\x87\x94R\x94\x8c\x07request\x94h\x00\x8c\x0fPreparedRequest\x94\x93\x94)\x81\x94}\x94(\x8c\x06method\x94\x8c\x04POST\x94h3h4h\x08h\x0b)\x81\x94}\x94h\x0eh\x11)R\x94(\x8c\nuser-agent\x94\x8c\nUser-Agent\x94\x8c\x16python-requests/2.31.0\x94\x86\x94\x8c\x0faccept-encoding\x94\x8c\x0fAccept-Encoding\x94\x8c\x11gzip, deflate, br\x94\x86\x94\x8c\x06accept\x94\x8c\x06Accept\x94\x8c\x03*/*\x94\x86\x94\x8c\nconnection\x94\x8c\nConnection\x94\x8c\nkeep-alive\x94\x86\x94\x8c\rauthorization\x94\x8c\rAuthorization\x94\x8cJBearer cf-tF35eifzMDB0e0pJBGAHE03dHIE5ignkHEkwZP5mERHK4Hl5OuQY9wZao9c7807F\x94\x86\x94\x8c\x0ccontent-type\x94\x8c\x0cContent-Type\x94\x8c\x10application/json\x94\x86\x94\x8c\x0econtent-length\x94\x8c\x0eContent-Length\x94\x8c\x042452\x94\x86\x94usbhXh>)\x81\x94}\x94(hAhD)\x81\x94}\x94(hG\x88hH\x89hINhJ\x89hK\x89hL\x88hM\x89hNK\x00hO\x89hP\x89hQhThU)hVNhWJ\xc9\xbfBfubhX}\x94hWJ\xc9\xbfBfub\x8c\x04body\x94X\x94\t\x00\x00{\"source_code_being_tested\": \"import itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\ndef compare_lists(\\n    li1: List[int],\\n    li2: List[int],\\n    value_func1=None,\\n    value_func2=None,\\n) -> Tuple[Set[int], Set[int], Set[int]]:\\n    \\\"\\\"\\\"Compare *li1* and *li2*, return the results as a list in the following form:\\n\\n    [[data seen in both lists], [data only seen in li1], [data only seen in li2]]\\n\\n    and [data seen in both lists] contains 2 tuple: [(actual items in li1), (actual items in li2)]\\n\\n    * *value_func1* callback function to li1, applied to each item in the list, returning the **logical** value for comparison\\n    * *value_func2* callback function to li2, similarly\\n\\n    If not supplied, lists will be compared as it is.\\n\\n    Usage::\\n\\n        >>> compare_lists([1, 2, 3], [1, 3, 5])\\n        >>> ([(1, 3), (1, 3)], [2], [5])\\n\\n    Or with callback functions specified::\\n\\n        >>> f = lambda x: x['v']\\n        >>>\\n        >>> li1 = [{'v': 1}, {'v': 2}, {'v': 3}]\\n        >>> li2 = [1, 3, 5]\\n        >>>\\n        >>> compare_lists(li1, li2, value_func1=f)\\n        >>> ([({'v': 1}, {'v': 3}), (1, 3)], [{'v': 2}], [5])\\n\\n    \\\"\\\"\\\"\\n    if not value_func1:\\n        value_func1 = lambda x: x\\n    if not value_func2:\\n        value_func2 = lambda x: x\\n\\n    def to_dict(li, vfunc):\\n        return dict((k, list(g)) for k, g in itertools.groupby(li, vfunc))\\n\\n    def flatten(li):\\n        return reduce(list.__add__, li) if li else []\\n\\n    d1 = to_dict(li1, value_func1)\\n    d2 = to_dict(li2, value_func2)\\n\\n    if d1 == d2:\\n        return (li1, li2), [], []\\n\\n    k1 = set(d1.keys())\\n    k2 = set(d2.keys())\\n\\n    elems_left = flatten([d1[k] for k in k1 - k2])\\n    elems_right = flatten([d2[k] for k in k2 - k1])\\n\\n    common_keys = k1 & k2\\n    elems_both = flatten([d2[k] for k in common_keys])\\n\\n    return set(elems_both), set(elems_left), set(elems_right)\\n\", \"function_to_optimize\": {\"function_name\": \"compare_lists\", \"file_path\": \"/Users/saurabh/Library/CloudStorage/Dropbox/codeflash/cli/codeflash/result/list_example.py\", \"parents\": [], \"starting_line\": null, \"ending_line\": null}, \"dependent_function_names\": [], \"module_path\": \"codeflash.result.list_example\", \"test_module_path\": \"tests.test_compare_lists__unit_test_0\", \"test_framework\": \"pytest\", \"test_timeout\": 15, \"trace_id\": \"c30f35e1-7b6c-4cce-a52f-80f9478f1f59\", \"python_version\": \"3.11.7\"}\x94\x8c\x05hooks\x94}\x94\x8c\x08response\x94]\x94s\x8c\x0e_body_position\x94Nubub.",
            # )
            response = pickle.loads(
                b"\x80\x04\x95~h\x00\x00\x00\x00\x00\x00\x8c\x0frequests.models\x94\x8c\x08Response\x94\x93\x94)\x81\x94}\x94(\x8c\x08_content\x94B\xffW\x00\x00{\"generated_tests\": \"# imports\\n# function to test\\nimport itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\nimport pytest  # used for our unit tests\\nfrom codeflash.result.list_example import compare_lists\\n\\n# unit tests\\n\\n# Basic Functionality\\ndef test_identical_lists():\\n    assert compare_lists([1, 2, 3], [1, 2, 3]) == ({1, 2, 3}, set(), set())\\n\\ndef test_completely_different_lists():\\n    assert compare_lists([1, 2, 3], [4, 5, 6]) == (set(), {1, 2, 3}, {4, 5, 6})\\n\\ndef test_partially_overlapping_lists():\\n    assert compare_lists([1, 2, 3], [2, 3, 4]) == ({2, 3}, {1}, {4})\\n\\n# Edge Cases\\ndef test_empty_lists():\\n    assert compare_lists([], []) == (set(), set(), set())\\n\\ndef test_one_empty_list():\\n    assert compare_lists([1, 2, 3], []) == (set(), {1, 2, 3}, set())\\n    assert compare_lists([], [1, 2, 3]) == (set(), set(), {1, 2, 3})\\n\\ndef test_single_element_lists():\\n    assert compare_lists([1], [1]) == ({1}, set(), set())\\n    assert compare_lists([1], [2]) == (set(), {1}, {2})\\n    assert compare_lists([1], []) == (set(), {1}, set())\\n\\ndef test_lists_with_repeated_elements():\\n    assert compare_lists([1, 1, 2], [1, 2, 2]) == ({1, 2}, set(), set())\\n\\n# Callback Functions\\ndef test_identity_function():\\n    assert compare_lists([1, 2, 3], [1, 2, 3], value_func1=lambda x: x, value_func2=lambda x: x) == ({1, 2, 3}, set(), set())\\n\\ndef test_custom_functions():\\n    assert compare_lists([{'v': 1}, {'v': 2}], [1, 2], value_func1=lambda x: x['v']) == ({1, 2}, set(), set())\\n    assert compare_lists([1, 2, 3], [1, 2, 3], value_func1=lambda x: x % 2, value_func2=lambda x: x % 2) == ({1, 2}, set(), set())\\n\\n# Large Scale Test Cases\\ndef test_large_identical_lists():\\n    assert compare_lists(list(range(1000)), list(range(1000))) == (set(range(1000)), set(), set())\\n\\ndef test_large_completely_different_lists():\\n    assert compare_lists(list(range(1000)), list(range(1000, 2000))) == (set(), set(range(1000)), set(range(1000, 2000)))\\n\\ndef test_large_partially_overlapping_lists():\\n    assert compare_lists(list(range(1000)), list(range(500, 1500))) == (set(range(500, 1000)), set(range(500)), set(range(1000, 1500)))\\n\\n# Special Cases\\ndef test_lists_with_negative_numbers():\\n    assert compare_lists([-1, -2, -3], [-1, -2, -4]) == ({-1, -2}, {-3}, {-4})\\n\\ndef test_lists_with_mixed_positive_and_negative_numbers():\\n    assert compare_lists([-1, 2, -3], [1, -2, 3]) == (set(), {-1, 2, -3}, {1, -2, 3})\\n\\ndef test_lists_with_zero():\\n    assert compare_lists([0, 1, 2], [0, 2, 3]) == ({0, 2}, {1}, {3})\\n\\n# Non-Integer Lists\\ndef test_lists_with_strings():\\n    assert compare_lists(['a', 'b', 'c'], ['b', 'c', 'd']) == ({'b', 'c'}, {'a'}, {'d'})\\n\\ndef test_lists_with_mixed_types():\\n    assert compare_lists([1, 'a', 2], [2, 'a', 3]) == ({2, 'a'}, {1}, {3})\\n\\n# Performance and Scalability\\ndef test_very_large_lists():\\n    assert compare_lists(list(range(10000)), list(range(10000))) == (set(range(10000)), set(), set())\\n    assert compare_lists(list(range(10000)), list(range(5000, 15000))) == (set(range(5000, 10000)), set(range(5000)), set(range(10000, 15000)))\\n\\n# Lists with Complex Objects\\ndef test_lists_with_dictionaries():\\n    assert compare_lists([{'id': 1}, {'id': 2}], [{'id': 1}, {'id': 3}], value_func1=lambda x: x['id'], value_func2=lambda x: x['id']) == ({1}, {2}, {3})\\n\\ndef test_lists_with_tuples():\\n    assert compare_lists([(1, 2), (3, 4)], [(1, 2), (5, 6)]) == ({(1, 2)}, {(3, 4)}, {(5, 6)})\\n\\n# Lists with Nested Structures\\ndef test_lists_with_nested_lists():\\n    assert compare_lists([[1, 2], [3, 4]], [[1, 2], [5, 6]], value_func1=lambda x: tuple(x), value_func2=lambda x: tuple(x)) == ({(1, 2)}, {(3, 4)}, {(5, 6)})\\n\\n# Lists with Special Characters\\ndef test_lists_with_special_characters():\\n    assert compare_lists(['@', '#', '$'], ['#', '$', '%']) == ({'#', '$'}, {'@'}, {'%'})\\n\\nif __name__ == \\\"__main__\\\":\\n    pytest.main()\", \"instrumented_tests\": \"import dill as pickle\\nimport os\\ndef _log__test__values(values, duration, test_name, invocation_id):\\n    iteration = os.environ[\\\"CODEFLASH_TEST_ITERATION\\\"]\\n    with open(os.path.join('{codeflash_run_tmp_dir_client_side}', f'test_return_values_{iteration}.bin'), 'ab') as f:\\n        return_bytes = pickle.dumps(values)\\n        _test_name = f\\\"{test_name}\\\".encode(\\\"ascii\\\")\\n        f.write(len(_test_name).to_bytes(4, byteorder='big'))\\n        f.write(_test_name)\\n        f.write(duration.to_bytes(8, byteorder='big'))\\n        f.write(len(return_bytes).to_bytes(4, byteorder='big'))\\n        f.write(return_bytes)\\n        f.write(len(invocation_id).to_bytes(4, byteorder='big'))\\n        f.write(invocation_id.encode(\\\"ascii\\\"))\\nimport inspect\\nimport time\\nimport gc\\nfrom codeflash.result.list_example import compare_lists\\n\\ndef codeflash_wrap(wrapped, test_module_name, test_class_name, test_name, line_id, *args, **kwargs):\\n    test_id = f'{test_module_name}:{test_class_name}:{test_name}:{line_id}'\\n    if not hasattr(codeflash_wrap, 'index'):\\n        codeflash_wrap.index = {}\\n    if test_id in codeflash_wrap.index:\\n        codeflash_wrap.index[test_id] += 1\\n    else:\\n        codeflash_wrap.index[test_id] = 0\\n    codeflash_test_index = codeflash_wrap.index[test_id]\\n    invocation_id = f'{line_id}_{codeflash_test_index}'\\n    gc.disable()\\n    counter = time.perf_counter_ns()\\n    return_value = wrapped(*args, **kwargs)\\n    codeflash_duration = time.perf_counter_ns() - counter\\n    gc.enable()\\n    return (return_value, codeflash_duration, invocation_id)\\nimport pytest\\nimport itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\ndef test_identical_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [1, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_identical_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_identical_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_completely_different_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [4, 5, 6])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_completely_different_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_completely_different_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_partially_overlapping_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [2, 3, 4])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_partially_overlapping_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_partially_overlapping_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_empty_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([], [])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_empty_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_empty_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_one_empty_list():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_one_empty_list', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_one_empty_list:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([], [1, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_one_empty_list', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_one_empty_list:compare_lists:1', codeflash_invocation_id)\\n\\ndef test_single_element_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1], [1])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_single_element_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_single_element_lists:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1], [2])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_single_element_lists', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_single_element_lists:compare_lists:1', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1], [])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_single_element_lists', '2', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_single_element_lists:compare_lists:2', codeflash_invocation_id)\\n\\ndef test_lists_with_repeated_elements():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 1, 2], [1, 2, 2])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_repeated_elements', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_repeated_elements:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_identity_function():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [1, 2, 3], value_func1=lambda x: x, value_func2=lambda x: x)\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_identity_function', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_identity_function:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_custom_functions():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([{'v': 1}, {'v': 2}], [1, 2], value_func1=lambda x: x['v'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_custom_functions', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_custom_functions:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 2, 3], [1, 2, 3], value_func1=lambda x: x % 2, value_func2=lambda x: x % 2)\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_custom_functions', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_custom_functions:compare_lists:1', codeflash_invocation_id)\\n\\ndef test_large_identical_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(1000)), list(range(1000)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_large_identical_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_large_identical_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_large_completely_different_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(1000)), list(range(1000, 2000)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_large_completely_different_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_large_completely_different_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_large_partially_overlapping_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(1000)), list(range(500, 1500)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_large_partially_overlapping_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_large_partially_overlapping_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_negative_numbers():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([-1, -2, -3], [-1, -2, -4])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_negative_numbers', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_negative_numbers:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_mixed_positive_and_negative_numbers():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([-1, 2, -3], [1, -2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_mixed_positive_and_negative_numbers', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_mixed_positive_and_negative_numbers:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_zero():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([0, 1, 2], [0, 2, 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_zero', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_zero:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_strings():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(['a', 'b', 'c'], ['b', 'c', 'd'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_strings', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_strings:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_mixed_types():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([1, 'a', 2], [2, 'a', 3])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_mixed_types', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_mixed_types:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_very_large_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(10000)), list(range(10000)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_very_large_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_very_large_lists:compare_lists:0', codeflash_invocation_id)\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(list(range(10000)), list(range(5000, 15000)))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_very_large_lists', '1', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_very_large_lists:compare_lists:1', codeflash_invocation_id)\\n\\ndef test_lists_with_dictionaries():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([{'id': 1}, {'id': 2}], [{'id': 1}, {'id': 3}], value_func1=lambda x: x['id'], value_func2=lambda x: x['id'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_dictionaries', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_dictionaries:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_tuples():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([(1, 2), (3, 4)], [(1, 2), (5, 6)])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_tuples', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_tuples:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_nested_lists():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind([[1, 2], [3, 4]], [[1, 2], [5, 6]], value_func1=lambda x: tuple(x), value_func2=lambda x: tuple(x))\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_nested_lists', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_nested_lists:compare_lists:0', codeflash_invocation_id)\\n\\ndef test_lists_with_special_characters():\\n    _call__bound__arguments = inspect.signature(compare_lists).bind(['@', '#', '$'], ['#', '$', '%'])\\n    _call__bound__arguments.apply_defaults()\\n    codeflash_return_value, codeflash_duration, codeflash_invocation_id = codeflash_wrap(compare_lists, 'tests.test_compare_lists__unit_test_0', None, 'test_lists_with_special_characters', '0', **_call__bound__arguments.arguments)\\n    _log__test__values((_call__bound__arguments.arguments, codeflash_return_value), codeflash_duration, 'tests.test_compare_lists__unit_test_0:test_lists_with_special_characters:compare_lists:0', codeflash_invocation_id)\\nif __name__ == '__main__':\\n    pytest.main()\"}\x94\x8c\x0bstatus_code\x94K\xc8\x8c\x07headers\x94\x8c\x13requests.structures\x94\x8c\x13CaseInsensitiveDict\x94\x93\x94)\x81\x94}\x94\x8c\x06_store\x94\x8c\x0bcollections\x94\x8c\x0bOrderedDict\x94\x93\x94)R\x94(\x8c\x04date\x94\x8c\x04Date\x94\x8c\x1dTue, 14 May 2024 01:54:30 GMT\x94\x86\x94\x8c\x0ccontent-type\x94\x8c\x0cContent-Type\x94\x8c\x1fapplication/json; charset=utf-8\x94\x86\x94\x8c\x0econtent-length\x94\x8c\x0eContent-Length\x94\x8c\x0522527\x94\x86\x94\x8c\nconnection\x94\x8c\nConnection\x94\x8c\nkeep-alive\x94\x86\x94\x8c\x06server\x94\x8c\x06Server\x94\x8c\x07uvicorn\x94\x86\x94\x8c\x16x-content-type-options\x94\x8c\x16X-Content-Type-Options\x94\x8c\x07nosniff\x94\x86\x94\x8c\x0freferrer-policy\x94\x8c\x0fReferrer-Policy\x94\x8c\x0bsame-origin\x94\x86\x94\x8c\x1across-origin-opener-policy\x94\x8c\x1aCross-Origin-Opener-Policy\x94\x8c\x0bsame-origin\x94\x86\x94usb\x8c\x03url\x94\x8c#https://app.codeflash.ai/ai/testgen\x94\x8c\x07history\x94]\x94\x8c\x08encoding\x94\x8c\x05utf-8\x94\x8c\x06reason\x94\x8c\x02OK\x94\x8c\x07cookies\x94\x8c\x10requests.cookies\x94\x8c\x11RequestsCookieJar\x94\x93\x94)\x81\x94}\x94(\x8c\x07_policy\x94\x8c\x0ehttp.cookiejar\x94\x8c\x13DefaultCookiePolicy\x94\x93\x94)\x81\x94}\x94(\x8c\x08netscape\x94\x88\x8c\x07rfc2965\x94\x89\x8c\x13rfc2109_as_netscape\x94N\x8c\x0chide_cookie2\x94\x89\x8c\rstrict_domain\x94\x89\x8c\x1bstrict_rfc2965_unverifiable\x94\x88\x8c\x16strict_ns_unverifiable\x94\x89\x8c\x10strict_ns_domain\x94K\x00\x8c\x1cstrict_ns_set_initial_dollar\x94\x89\x8c\x12strict_ns_set_path\x94\x89\x8c\x10secure_protocols\x94\x8c\x05https\x94\x8c\x03wss\x94\x86\x94\x8c\x10_blocked_domains\x94)\x8c\x10_allowed_domains\x94N\x8c\x04_now\x94JV\xc4Bfub\x8c\x08_cookies\x94}\x94hWJV\xc4Bfub\x8c\x07elapsed\x94\x8c\x08datetime\x94\x8c\ttimedelta\x94\x93\x94K\x00K0J\xce:\x08\x00\x87\x94R\x94\x8c\x07request\x94h\x00\x8c\x0fPreparedRequest\x94\x93\x94)\x81\x94}\x94(\x8c\x06method\x94\x8c\x04POST\x94h3h4h\x08h\x0b)\x81\x94}\x94h\x0eh\x11)R\x94(\x8c\nuser-agent\x94\x8c\nUser-Agent\x94\x8c\x16python-requests/2.31.0\x94\x86\x94\x8c\x0faccept-encoding\x94\x8c\x0fAccept-Encoding\x94\x8c\x11gzip, deflate, br\x94\x86\x94\x8c\x06accept\x94\x8c\x06Accept\x94\x8c\x03*/*\x94\x86\x94\x8c\nconnection\x94\x8c\nConnection\x94\x8c\nkeep-alive\x94\x86\x94\x8c\rauthorization\x94\x8c\rAuthorization\x94\x8cJBearer cf-tF35eifzMDB0e0pJBGAHE03dHIE5ignkHEkwZP5mERHK4Hl5OuQY9wZao9c7807F\x94\x86\x94\x8c\x0ccontent-type\x94\x8c\x0cContent-Type\x94\x8c\x10application/json\x94\x86\x94\x8c\x0econtent-length\x94\x8c\x0eContent-Length\x94\x8c\x042452\x94\x86\x94usbhXh>)\x81\x94}\x94(hAhD)\x81\x94}\x94(hG\x88hH\x89hINhJ\x89hK\x89hL\x88hM\x89hNK\x00hO\x89hP\x89hQhThU)hVNhWJ&\xc4BfubhX}\x94hWJ&\xc4Bfub\x8c\x04body\x94X\x94\t\x00\x00{\"source_code_being_tested\": \"import itertools\\nfrom functools import reduce\\nfrom typing import List, Set, Tuple\\n\\ndef compare_lists(\\n    li1: List[int],\\n    li2: List[int],\\n    value_func1=None,\\n    value_func2=None,\\n) -> Tuple[Set[int], Set[int], Set[int]]:\\n    \\\"\\\"\\\"Compare *li1* and *li2*, return the results as a list in the following form:\\n\\n    [[data seen in both lists], [data only seen in li1], [data only seen in li2]]\\n\\n    and [data seen in both lists] contains 2 tuple: [(actual items in li1), (actual items in li2)]\\n\\n    * *value_func1* callback function to li1, applied to each item in the list, returning the **logical** value for comparison\\n    * *value_func2* callback function to li2, similarly\\n\\n    If not supplied, lists will be compared as it is.\\n\\n    Usage::\\n\\n        >>> compare_lists([1, 2, 3], [1, 3, 5])\\n        >>> ([(1, 3), (1, 3)], [2], [5])\\n\\n    Or with callback functions specified::\\n\\n        >>> f = lambda x: x['v']\\n        >>>\\n        >>> li1 = [{'v': 1}, {'v': 2}, {'v': 3}]\\n        >>> li2 = [1, 3, 5]\\n        >>>\\n        >>> compare_lists(li1, li2, value_func1=f)\\n        >>> ([({'v': 1}, {'v': 3}), (1, 3)], [{'v': 2}], [5])\\n\\n    \\\"\\\"\\\"\\n    if not value_func1:\\n        value_func1 = lambda x: x\\n    if not value_func2:\\n        value_func2 = lambda x: x\\n\\n    def to_dict(li, vfunc):\\n        return dict((k, list(g)) for k, g in itertools.groupby(li, vfunc))\\n\\n    def flatten(li):\\n        return reduce(list.__add__, li) if li else []\\n\\n    d1 = to_dict(li1, value_func1)\\n    d2 = to_dict(li2, value_func2)\\n\\n    if d1 == d2:\\n        return (li1, li2), [], []\\n\\n    k1 = set(d1.keys())\\n    k2 = set(d2.keys())\\n\\n    elems_left = flatten([d1[k] for k in k1 - k2])\\n    elems_right = flatten([d2[k] for k in k2 - k1])\\n\\n    common_keys = k1 & k2\\n    elems_both = flatten([d2[k] for k in common_keys])\\n\\n    return set(elems_both), set(elems_left), set(elems_right)\\n\", \"function_to_optimize\": {\"function_name\": \"compare_lists\", \"file_path\": \"/Users/saurabh/Library/CloudStorage/Dropbox/codeflash/cli/codeflash/result/list_example.py\", \"parents\": [], \"starting_line\": null, \"ending_line\": null}, \"dependent_function_names\": [], \"module_path\": \"codeflash.result.list_example\", \"test_module_path\": \"tests.test_compare_lists__unit_test_0\", \"test_framework\": \"pytest\", \"test_timeout\": 15, \"trace_id\": \"60c55e7e-987c-4acf-b00b-98015dba3877\", \"python_version\": \"3.11.7\"}\x94\x8c\x05hooks\x94}\x94\x8c\x08response\x94]\x94s\x8c\x0e_body_position\x94Nubub."
            )
            time.sleep(10)
        except requests.exceptions.RequestException as e:
            logging.exception(f"Error generating tests: {e}")
            ph("cli-testgen-error-caught", {"error": str(e)})
            return None

        # the timeout should be the same as the timeout for the AI service backend

        if response.status_code == 200:
            response_json = response.json()

            logging.info(f"Generated tests for function {function_to_optimize.function_name}")
            return response_json["generated_tests"], response_json["instrumented_tests"]
        else:
            try:
                error = response.json()["error"]
                logging.error(f"Error generating tests: {response.status_code} - {error}")
                ph(
                    "cli-testgen-error-response",
                    {"response_status_code": response.status_code, "error": error},
                )
                return None
            except Exception:
                logging.exception(f"Error generating tests: {response.status_code} - {response.text}")
                ph(
                    "cli-testgen-error-response",
                    {"response_status_code": response.status_code, "error": response.text},
                )
                return None


class LocalAiServiceClient(AiServiceClient):
    def get_aiservice_base_url(self) -> str:
        return "http://localhost:8000"
